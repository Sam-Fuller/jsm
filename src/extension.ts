/* eslint-disable max-len */

import * as vscode from 'vscode';

const apply = (f: (text: string) => string) => {
    const editor = vscode.window.activeTextEditor;

    if (!editor) return;

    if (
        editor.selections.length > 1
        || (editor.selections.length
            && editor.selections[0].start.line !== editor.selections[0].end.line
            && editor.selections[0].start.character
            !== editor.selections[0].end.character)
    ) {
        editor.edit((editBuilder) => {
            editor?.selections.map((selection: vscode.Selection) => {
                const text = editor?.document.getText(selection);

                const newText = f(text);

                editBuilder.replace(selection, newText || ``);
            });
        });
    } else {
        editor.edit((editBuilder) => {
            const text = editor?.document.getText();

            const newText = f(text);

            const lastLine = editor?.document.lineCount - 1;
            const lastChar = editor?.document.lineAt(lastLine).text.length;

            editBuilder.replace(
                new vscode.Range(
                    new vscode.Position(0, 0),
                    new vscode.Position(lastLine, lastChar),
                ),

                newText || ``,
            );
        });
    }
};

const mapLines = (f: (text: string) => string) => (text: string) =>
    text.split(/\r?\n/).map(f).join(`\n`);

const filterLines = (f: (text: string) => string) => (text: string) =>
    text.split(/\r?\n/).filter(f).join(`\n`);

const sortLines = () => (text: string) => text.split(/\r?\n/).sort().join(`\n`);

// ty to https://stackoverflow.com/questions/11233498/json-stringify-without-quotes-on-properties
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const objToString = (obj: any): string => {
    const cleaned = JSON.stringify(obj, null, 4);

    return cleaned.replace(/^[\t ]*"[^:\n\r]+(?<!\\)":/gm, function (match) {
        return match.replace(/"/g, ``);
    });
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const applyJS = (f: (text: unknown) => any) => (text: string) => {
    return objToString(f(eval(`(${text})`)));
};

const filterJS = (f: (text: unknown) => boolean) => (text: string) => {
    return objToString(eval(`(${text})`).filter(f));
};

const sortJS = (f: (text: unknown) => number) => (text: string) => {
    return objToString(eval(`(${text})`).sort(f));
};

const toJSFunction = (fString?: string) => {
    if (!fString) return undefined;

    const f = eval(fString);

    return f;
};

export const activate = (context: vscode.ExtensionContext): void => {
    context.subscriptions.push(
        vscode.commands.registerTextEditorCommand(`jsm.lineMap`, () => {
            vscode.window
                .showInputBox({
                    title: `map a function across every line in a file or selection`,
                    value: `(line, index) => `,
                })
                .then((value) => {
                    apply(mapLines(toJSFunction(value)));
                });
        }),
    );

    context.subscriptions.push(
        vscode.commands.registerTextEditorCommand(`jsm.lineFilter`, () => {
            vscode.window
                .showInputBox({
                    title: `filter each line, keeping only those that satisfy a predicate`,
                    value: `(line, index) => `,
                })
                .then((value) => {
                    apply(filterLines(toJSFunction(value)));
                });
        }),
    );

    context.subscriptions.push(
        vscode.commands.registerTextEditorCommand(`jsm.lineSort`, () => {
            apply(sortLines());
        }),
    );

    context.subscriptions.push(
        vscode.commands.registerTextEditorCommand(`jsm.lineFilterRegex`, () => {
            vscode.window
                .showInputBox({
                    title: `filter each line, keeping only those that match a regex`,
                    value: `\\\\`,
                })
                .then((value) => {
                    apply(
                        filterLines(
                            toJSFunction(`(line) => line.match(${value})`),
                        ),
                    );
                });
        }),
    );

    context.subscriptions.push(
        vscode.commands.registerTextEditorCommand(`jsm.lineMapRegex`, () => {
            vscode.window
                .showInputBox({
                    title: `apply a regex to each line, keeping only the capture groups`,
                    value: `\\\\`,
                })
                .then((regex) => {
                    vscode.window
                        .showInputBox({
                            title: `apply a function to the list of groups for each line generated by the regex`,
                            value: `(groups) => groups.join('')`,
                        })
                        .then((f) => {
                            apply(
                                filterLines(
                                    toJSFunction(
                                        `(line) => line.exec(${regex}).map(${f})`,
                                    ),
                                ),
                            );
                        });
                });
        }),
    );

    context.subscriptions.push(
        vscode.commands.registerTextEditorCommand(`jsm.fileApply`, () => {
            vscode.window
                .showInputBox({
                    title: `apply a function across an entire file`,
                    value: `(text) => `,
                })
                .then((value) => {
                    apply(toJSFunction(value));
                });
        }),
    );

    context.subscriptions.push(
        vscode.commands.registerTextEditorCommand(`jsm.fileGenerate`, () => {
            vscode.window
                .showInputBox({
                    title: `generate lines using a function for each line`,
                    value: `(index, prev) => `,
                })
                .then((f) => {
                    vscode.window
                        .showInputBox({
                            title: `define the maximum number of lines to generate`,
                        })
                        .then((limit) => {
                            const editor = vscode.window.activeTextEditor;
                            if (!editor) return;

                            editor.edit((editBuilder) => {
                                const array = [
                                    ...Array(
                                        Number.parseInt(limit || `1`),
                                    ).keys(),
                                ];

                                for (const index of array) {
                                    array[index] = toJSFunction(f)(
                                        index,
                                        array[index - 1],
                                    );
                                }

                                const lastLine = editor?.document.lineCount - 1;
                                const lastChar
                                    = editor?.document.lineAt(lastLine).text
                                        .length;

                                editBuilder.replace(
                                    new vscode.Range(
                                        new vscode.Position(0, 0),
                                        new vscode.Position(lastLine, lastChar),
                                    ),

                                    array.join(`\n`),
                                );
                            });
                        });
                });
        }),
    );

    context.subscriptions.push(
        vscode.commands.registerTextEditorCommand(`jsm.jsApply`, () => {
            vscode.window
                .showInputBox({
                    title: `apply a function to a single javascript object`,
                    value: `(object) => ({...object})`,
                })
                .then((value) => {
                    apply(applyJS(toJSFunction(value)));
                });
        }),
    );

    context.subscriptions.push(
        vscode.commands.registerTextEditorCommand(`jsm.jsFilter`, () => {
            vscode.window
                .showInputBox({
                    title: `filter each object, keeping only those that match a regex`,
                    value: `(object) => `,
                })
                .then((value) => {
                    apply(filterJS(toJSFunction(value)));
                });
        }),
    );

    context.subscriptions.push(
        vscode.commands.registerTextEditorCommand(`jsm.jsSort`, () => {
            vscode.window
                .showInputBox({
                    title: `sort each object by defining a comparison function`,
                    value: `(a, b) => `,
                })
                .then((value) => {
                    apply(sortJS(toJSFunction(value)));
                });
        }),
    );

    context.subscriptions.push(
        vscode.commands.registerTextEditorCommand(`jsm.jsToJson`, () => {
            apply((text) => {
                return JSON.stringify(toJSFunction(`(${text})`), null, 4);
            });
        }),
    );

    context.subscriptions.push(
        vscode.commands.registerTextEditorCommand(`jsm.jsonToJs`, () => {
            apply((text) => objToString(JSON.parse(text)));
        }),
    );

    context.subscriptions.push(
        vscode.commands.registerTextEditorCommand(`jsm.csvToJs`, () => {
            apply((data: string) => {
                const delimiter = ","
                const titles = data.slice(0, data
                    .indexOf('\n')).split(delimiter);

                const titleValues = data.slice(data
                    .indexOf('\n') + 1).split('\n');

                const ansArray = titleValues.map(function (v) {

                    const values = v.split(delimiter);

                    const storeKeyValue = titles.reduce(
                        function (obj, title, index) {
                            obj[title] = values[index];
                            return obj;
                        }, {});

                    return storeKeyValue;
                });

                return ansArray;
            });
        }),
    );

    context.subscriptions.push(
        vscode.commands.registerTextEditorCommand(`jsm.JsToCsv`, () => {
            apply(toJSFunction(`(${text})`)
                .map((row) =>
                    row.map((cell) => JSON.stringify(cell)).join(`,`)
                ).join(`\n`)
            );
        }),
    );
};

export const deactivate = (): undefined => undefined;
